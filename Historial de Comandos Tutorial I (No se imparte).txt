https://github.com/bvivess/SRV/blob/master/BLOC2/blog2/app/Models/Comment.php

/////////////////////////////////////////////////////
Clase 1 y Clase 2
Instalación y Configuración de Herramientas
Creación del Entorno y Primeros pasos
Creación y Gestión de la DDBB
/////////////////////////////////////////////////////


/////////////////////////////////////////////  Preparación del Entorno 

// Instalar laragon https://laragon.org/. Es una herramienta integrada, similar al XAMPP, ofrece (Apache 2.4, Nginx, MySQL 8, PHP 8, Redis, Memcached, Node.js 18, npm, git), etc.
// Iniciar Apache y MySQL, si tenemos instalaciones nativas de apache y MySQL (Servicio MYSQL80) detenerlas para evitar conflictos
// Iniciar Visual Studio Code e instalar los siguientes plugins para el entorno de Laravel:
//	Laravel Snippets: Autocompletar fragmento de código
//	Laravel Blade Snipets: Autocompletar fragmento de código 
//	Laravel Goto view: Desde ruta de una vista saltar a la vista
//	Material Icon Theme: Crea los iconos identificativos de los archivos de un proyecto Laravel
//	PHP Namespaces Resolver: Facilita importación de clases y dependencias del código

// En Laragon, asegurarse de que se tienen las últimas versiones de PHP, Apache y Laravel --> Ojo, tiene que ser compatible la versión de PHP y la de Apache
// 	PHP: 8.3.11 / 8.3.13 / 8.5 (https://www.php.net/downloads.php) bajar última y copiar fichero descomprimido en (C:\laragon\bin\php) 
//		luego acceder al menú de Laragon y seleccionar esta última versión de PHP. 
//		Ojo, he tenido que mover los ficheros a carpeta superior, para que no de error. 
//		Yo tengo la php-8.3.13-nts-Win32-vs16-x64
//	Apache: 2.4.62 / 2.4.65 (https://www.apachelounge.com/download/) bajar última y copiar fichero descomprimido en (C:\laragon\bin\apache)
//		Yo tengo la httpd-2.4.54-win64-VS16
// 	Laravel: 11.30/11.31/11.36.1 (arancar Laragon, acceder al terminal, acceder a cualquier proyecto y λ php artisan --version) 
// 	OJO con las veriones de PHP / APACHE que tiene que ser compatibles y no dar problemas
//		php-8.3.13-nts-Win32-vs16-x64 / httpd-2.4.54-win64-VS16


//////// Creación del Proyecto 


// Creamos el proyecto
// Arrancar el terminal de Laragon, nos ubica en C:\laragon\www

composer create-project laravel/laravel <example-app> 	// Creación de un proyecto denominado "example-app" mediante Composer.
							// De esta manera es necesario tener Composer y PHP ya instalados (Laragon) 
							// OJO, en el portátil tarda bastante, tener paciencia. 
cd <example-app>	// Ubicación en el directorio del proyecto C:\laragon\www\example-app, aquí está la estructura del framework Laravel
			// Todo los comandos excepto la creación del proyecto, deben aplicarse al proyecto, por tanto, ubicarse en la carpeta del proyecto
php artisan --version // Para conocer la versión instalada de Laravel, Laravel Framework 11.22.0 / 11.30.0 / 11.31.0 / 11.36.1 / 12.41.1 / etc.

//Otra manera de proceder a la creación del proyecto (No lo he probado) 
	// composer global require laravel/installer
	// laravel new nom-app
	// cd nom-app

λ php artisan serve // Inicia servidor local: Server running on [http://127.0.0.1:8000] si puede puerto 8000 (si está ocupado 8001,8002, ...)  
		 // Comprobarlo conectando a http://localhost:8000. Obtenemos pantalla inicial proyecto (que genera un error) 

http://127.0.0.1:8000 // 
http://<example-app>.test // Esto no funciona bien. Hay que reiniciar el Laragon para que genere el virtual server
			// Al reinicio aparece el aviso de Windows
			// Seguirá fallando porque no hemos configurado la DDBB

// Arrancar el VS Code y acceder a la carpeta del proyecto C:\laragon\www\<example-app>
// Se observa la estructura creada de directorios y archivos del proyecto Laravel

// Revisar la configuración de la DDBB mediante el VS
// Acceder al archivo .env (está en raíz de la estructura) y corroborar los parámetros de conexión a la DDBB (suelen estar comentados)
	// DB_CONNECTION=mysql //este hay que cambiarlo, originalmente indica otro. 
	// DB_HOST=127.0.0.1
	// DB_PORT=3306
	// DB_DATABASE=example-app //indicar nombreproyecto-app, ejemplo: example-app, blog-app, etc. 
	// DB_USERNAME=root
	// DB_PASSWORD=

// Una vez configurada la DDBB
// ahora hay que crear la DDBB inicial del proyecto
// Aceder al VS en database>migration se observa la migración inicial de la DDBB (3 migraciones) que se general x defecto al crear el proyecto
// 0001_01_01_000000_create_users_table.php
// 0001_01_01_000001_create_cache_table.php
// 0001_01_01_000002_create_jobs_table.php
// Hay que lanzar estas 3 migraciones para generar la DDBB inicial del proyect

// La migración se lanza de la siguiente manera:
php artisan migrate 	// Crea la DDBB inicial de la aplicación <example-app>; son las migraciones que hemos visto 
			// Las migraciones controlan las versiones de la DDBB del proyecto
			// Las migraciones iniciales están creadas por la creación del proyecto 
			// Acceder con el Heidi (Herramienta de DDBB de Laragon para corroborar la DDBB está generada) 
			// La estructura debe coincidir con las migraciones. Es una estructura x defecto para proyectos de Laravel

http://<example-app>.test // Ahora SI ya debería funcionar con la pantalla inicial de Laravel

//// Comenzamos instalando dos módulos estádard en nuestro proyecto 
// 	El breeze: (es un login ya hecho y estándard)
// 	EL barryvdh (es una barra de degub) --> No lo suelo instalar, o nunca lo he usado.


λ composer require laravel/breeze --dev // Instala un módulo de la funcionalidad de login de nuestra aplicación
λ php artisan breeze:install // Seleccionamos blade
				// Dark Mode NO
				// PHPUnit 

  Which Breeze stack would you like to install?
  Blade with Alpine .......................................................................................................................... blade
  Livewire (Volt Class API) with Alpine ................................................................................................... livewire
  Livewire (Volt Functional API) with Alpine ................................................................................... livewire-functional
  React with Inertia ......................................................................................................................... react
  Vue with Inertia ............................................................................................................................. vue
  API only ..................................................................................................................................... api
❯ blade
blade

  Would you like dark mode support? (yes/no) [no]
❯ no

  Which testing framework do you prefer? [Pest]
  Pest ........................................................................................................................................... 0
  PHPUnit ........................................................................................................................................ 1
❯ 1
1

// Creación de la DDBB física y frontend
php artisan migrate
npm install
npm run dev


// php require laravel/jetstream // Es otro login ya construído con utilidades de login
// php artisan jetstrem:install // Otra manera de instalar el jeststream (creo) 


// Probar con el navegador que ya tenemos el login de nuestra apliación
http://<example-app>.test/  	// Debería aparecer una pantalla con opción de "login" y de "register" 
				// Si nos registramos, podemos comprobar en la DDBB mediante Laragon que se ha creado nuestro usuario
				// Name: Tomeu Sabater
				// e-mail: bsabater@iesemilidarder.com
				// password: tomeutomeu

composer require barryvdh/laravel-debugbar --dev // Instala una barra de debug que puede ser útil (yo normalmente no la instalo)
// Probar con el navegador que ya tenemos la barra de debug
http://<example-app>.test/  // Login con el usuario registrado anterioremente 
			// Comprobar que a pié de página del navegador existe una barra de debug


///////////////////////////////////////////// Creación de la DDBB del Proyecto

//// Hasta ahora, hemos configurado el entorno y hemos creado la estructura de nuestro proyecto 
//// En nuestro proyecto hemos instalado plugins; Login y (Debug -> opcional)
//// Ahora vamos a comenzar a crear la DDBB de nuestro proyecto

// Es importante entender el concepto de 'migración'
// Las migraciones son el control de versiones de Laravel para la DDBB

// Comandos para la DDBB

// php artisan make:migration create_categories_table // Crearía la estructura de una migración para una tabla de categorías
// php artisan make:migration create_posts_table // Crearía la estructura de una migración para una tabla de publicaciones 
// php artisan make:migration create_tags_table // Crearía la estructura de una migración para una tabla de etiquetas
// php artisan make:migration create_post_tag_table // Crearía la estructura de una migración para una tabla intermedia etiquetas y publicaciones 
// php artisan make:migration create_comments_table // Crearía la estructura de una migración para una tabla de comentarios
// php artisan make:migration create_images_table // Crearía la estructura de una migracion para una tabla de imágenes (enlaces a la imagen) 
// php artisan make:migration add_role_to_users_table // Crearía la estructura que añade un campo "role" a la tabla de usuarios


// Otros ejemplos 
// php artisan make:migration change_name_to_posts_table // Crearía la estructura para modificar una columna existente
// php artisan make:migration remove_email_from_users_table // Para eliminar una columna
// php artisan make:migration drop_posts_table // Para eliminar una tabla

// php artisan migrate // Lanzaría las migraciones para el C/U/D de las tablas físicas


// Vamos a crear las migraciones, una a una, para cada una de las tablas que vamos a necesitar
// Las migraciones se van a crear en el orden que necesitemos crear las tablas en la DDBB física (orden impuesto por FKs)
// Las migraciones se ubican en database>migrations>año_mes_dia_horaminutsegon_nombremigracion.php

// Es importante respetar la NOMENCLATURA de Laravel, esto permitirá que Laravel pueda asociar automáticamente
// 	un Modelo a su Tabla correspondiente, sin que sea necesario especificarlo explícitamente
// Tabla y Modelo definido por una sola palabra, por ejemplo Posts
// 	Modelo: Post -> En singular y en formato Pascalcase
// 	Tabla: posts -> En plural y en formato snake_case 
// Tabla y Modelo definido por más de una palabra, por ejemplo Posts Types 
// 	Modelo: PostType 
// 	Tabla: post_types
// Atención, las Tablas de una relación N:M (que aparecen en el modelo físico), por ejemplo entre Posts y Tags
// 	Modelo: PostTag -> En singular, ordenadas alfabéticamente y en formato sanke_case
//	Tabla: tablaM_tablaN -> En singular, ordenadas alfabéticamente i en formato snake_case


// Vamos a crear TODAS la tablas físicas, o la estructura de la DDBB, mediante migraciones. 
// Antes vamos a recordar algunas instrucciones que nos pueden salvar la vida
// Cómo VOLVER ATRÁS (rollback) si hemos cometido un error
php artisan migrate:rollback // Retrocede TODAS las migraciones registradas en la tabla 'migrations'
php artisan migrate:rollback --step=1 // Retrocede 1 paso (la última migración)
						//  Este rollback --step=1 está pensado para retroceder la última migración si nos hemos equivocado:
						// 	1.- Aplicar el rollback --step=1
						// 	2.- Solventar el error dentro del fichero de migración del VS
						// 	3.- Volver a aplicar la migración (se ejecutará otra vez el último archivo // o lo que no haya en la tabla migrations) 
						//	Observación:	El migrate ejecutará la función up() del fichero de migración
						//			El rollback ejecutará la función down() del fichero de migración


****************************************************************** INICIO CREACIÓN FÍSICA DE LA DDBB

// Creamos la tabla Categories
php artisan make:migration create_categories_table 	//Crea el esqueleto de la tabla en VS en app>migrations>fecha_create_categories_table.php
							// editar en VS que sea como esto en la función up()
            						// $table->id();
            						// $table->string('title',500)->nullable(); 
            						// $table->string('url_clean',500)->nullable(); 
            						// $table->timestamps();

							// Añadir esto en la función down()
							// Schema::dropIfExists('categories') // Que eliminaría la tabla si hacemos rollback
//Ejecutar la migración
php artisan migrate	// Recuerda que esto es la ejecución de la DDL del código php. 
			// comprobar con Laragon Heidi que la tenemos en la DDBB la tabla de categories 

// Creamos la tabla de 'posts', en nuestro modelo será la tabla de publicaciones (no confundir com method='post') 
// Según nomenclatura, el nombre de la tabla en inglés en plural
php artisan make:migration create_posts_table 	// creación de la estructura de la tabla "posts" y comprobarlo en VSC, pero no estará en la DDBB todavía
						// Lo que hemos hecho ha sido crear en VS el fichero de creación de la tabla. 
						// Comprobarlo en el VS en database>migrations>fecha_create_posts_table.php
						// Añadir a este fichero el resto de campos en la función up(). Ojo con los decoradores. 
						// $table->id();
						// $table->string('title', 500)->nullable();
						// $table->string('url_clean', 500)->nullable();
						// $table->text('content')->nullable();
						// $table->enum('posted', ['yes', 'not'])->default('not');
						// $table->foreignId('user_id')->constrained()->onUpdate('restrict')->onDelete('restrict');
						// $table->foreignId('category_id')->constrained()->onUpdate('restrict')->onDelete('restrict');
						// $table->timestamps(); // crea dos campos; created_at y updated_at

						// Añadir esto en la función down()
						// Schema::dropIfExists('posts'); // que borrará la tabla si deseamos hacer un rollback
// Ejecutamos la migración						
php artisan migrate 				// Recuerdar que es la ejecución de la DDL del código php. 
						// y ahora sí, comprobar la base de datos con el Laragon que la tabla "posts" ya existe. 
						// A la vez, comprobar el track de migraciones en la DDBB con Laragon en la tabla 'migrations'

// Creamos la tabla tags
php artisan make:migration create_tags_table

		//    public function up(): void
		//    {
		//        Schema::create('tags', function (Blueprint $table) {
		//            $table->id();
		//            $table->string('name', 250)->nullable()->unique();
		//            $table->string('url_clean', 500)->nullable();
		//            $table->timestamps();
		//        });
		//    }
		//
		//    public function down(): void
		//    {
		//        Schema::dropIfExists('tags');
		//    }

λ php artisan migrate

// Recordar que en migración una N:M la migración se escribe en singular las 2 y ordenado alfabéticamenete
// 	y en migración una tabla con nombre compuesto, primera en singular y la segunda en plural ordenado alfabéticamente
λ php artisan make:migration create_post_tag_table

// Y en databas>migrations>create_post_tag_table


	//    public function up(): void
	//    {
	//        Schema::create('post_tag', function (Blueprint $table) {
	//            $table->id();
	//           $table->foreignId('post_id')->constrained();
	//            $table->foreignId('tag_id')->constrained();
	//            $table->timestamps();
	//        });
	//    }
	//
	//    /**
		//     * Reverse the migrations.
	//     */
	//    public function down(): void
	//    {
	//        Schema::dropIfExists('post_tag');
	//    }

php artisan migrate

// Comprobarlo con el Heidi
// comprobar que tenemos la tabla post_tag y que es una N:M con las tablas posts y tags

// Esta vez, no haremos caso a la nomenclatura y crearemos la tabla N:M con un nombre 'comments' 
// Ojo que haremos de otra manera las FK

λ php artisan make:migration create_comments_table

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('comments', function (Blueprint $table) {
            $table->id();
            $table->text('comment');            
            $table->foreignId('post_id')->constrained();
            $table->foreignId('user_id')->constrained();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('comments');
    }
};

λ php artisan migrate

// Nos falta la tabla images, que tiene una FK con comments
λ php artisan make:migration create_images_table

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('images', function (Blueprint $table) {
            $table->id();
            $table->string('url');
            $table->foreignId('comment_id')->constrained()->onDelete('restrict');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('images');
    }
};

λ php artisan migrate

λ php artisan make:migration create_roles_table

    public function up(): void
    {
        Schema::create('roles', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->timestamps();
        });
    }

// Añadir un campo 'role_id' en la tabla users
// La tabla users se creó automáticamente con las 3 primeras migraciones
php artisan make:migration add_role_to_users_table 	// Esta vez, añadimos a la tabla users un campo nuevo que no posee
							// ojo con la nomenclatura y crea en VS una nueva migración
							// entrar en VS dabatase>migrations>fecha_add_role_to_users_table.php 
							// Dejarlo así para crear nuevo campo y que se posicione en el lugar adecuado
							
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {

            $table->bigInteger('role_id')->after('id')->unsigned()->nullable();
            $table->foreign('role_id')->references('id')->on('roles');

        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn('role_id');
        });
    }

// Ejecutar la estructura creada en el VS
php artisan migrate 	// Entrar en DDBB con Laragon y comprobar la nueva columna y que todo es correcto
			// Si hay error, aplicar un rollback --step=1, arreglar la estructura en el VS y aplicar migración


*********************************************************************** FIN CREACIÓN FÍSICA DE LA DDBB

///////////////////////////////////////////////////////////  INICIO OTRAS OPERACIONES POSIBLES 

///// Otras operciones posibles con migraciones 

// Otro ejemplo, cambiamos el TYPE a un campo de la tabla users 
php artisan make:migration change_name_to_users_table  	// Creamos migracion para cambiar el tipo de una columna
							// Acceder al VS database>migrations>fecha_change_name_to_users_table.php y dejarlo así  
							// public function up(): void
   							// {
							//        Schema::table('users', function (Blueprint $table) {
							//            $table->string('name',150)->change();
							// });
							//
							// public function down(): void
    							// {
							//        Schema::table('users', function (Blueprint $table) {
							//            $table->string('name',255)->change();
							//        });
							//  }


// Ejecutar la migración
php artisan migrate // Y comprobarlo en la DDBB con el Laragon Heidi

// Indagar para cambiar el nombre de un campo, por ejemplo, de 'role' a 'rol' y viceversa. 
php artisan make:migration change_columnname_role_to_users_table // Creamos la plantilla de la migración en VS
								// en up(): $table->renameColumn('role', 'rol');
								// en down(): $table->renameColumn('rol', 'role'); // Como establa
php artisan migrate // Y comprobar en DDBB con Laragon que se ha efectuado el cambio
php artisan migrate:rollback --step=1 // Deshacemos el cambio recién hecho para volver a dejar "role" como nombre de campo
					// El step --1 indica deshacer la última migración
					// Ver las migraciones en la DDBB con Laragon en la tabla "migrations"

///// FKs
// Veamos la creación de las FKs, hay varias maneras: 
// En la tabla "posts" hay que añadir las FK hacia "users" y hacia "categories"

// Comenzamos con la FK hacia "users" mediante la siguiente migración
php artisan make:migration add_user_id_to_posts_table // Creamos el esqueleto de la creación de FKs
							// public function up(): void
							// {
							//     Schema::table('posts', function (Blueprint $table) {
							//         $table->unsignedBigInteger('user_id')->after('posted');
							//         $table->foreign('user_id')->references('id')->on('users'); 
							// 	});
							// }
							// 
							// public function down(): void
							// {
							//     Schema::table('posts', function (Blueprint $table) {
							//         $table->dropForeign('posts_user_id_foreign');
							//         $table->dropColumn('user_id');
							//      });
							// }

php artisan migrate // Como siempre, aplicamos la migración, comprobarlo con el Heidi 

///////////////////////////////////////////// FKs

// Ahora con la FK hacia "categories", se haría de manera similar 
// Pero cuidado porque primero hay que cambiar el type de Category_id de la tabla posts 
// Cuando se ha creado, se ha creado como $table->bigInteger('category_id')->unsignet()->nullable();
// Y el tipo de dato no es el mismo, tiene 19 y necesitamos 20 para que coincida con el tipo de dato del category_id
// Hay que cambiarlo a $table->unsignedBigInteger('category_id')->after('user_id')->change();

php artisan make:migration change_columntype_category_id_to_posts_table

				//    public function up(): void
				//    {
				//        Schema::table('posts', function (Blueprint $table) {
				//            $table->unsignedBigInteger('category_id')->after('user_id')->change();
				//        });
				//    }
				//
				//    public function down(): void
				//    {
				//        Schema::table('posts', function (Blueprint $table) {
				//            $table->bigInteger('category_id',19)->unsignet()->nullable()->change();
				//        });
				//    }

λ php artisan migrate

// Comprobar ahora en Heidi que el tipo de dato coincide
// no hemos acabado, ahora hay que hacer que sea una FK

php artisan make:migration add_category_id_fk_to_posts_table // Creamos el esqueleto de la creación de FKs

				//    public function up(): void
				//    {
				//        Schema::table('posts', function (Blueprint $table) {
				//            $table->foreign('category_id')->references('id')->on('categories'); 
				//        });
				//    }
				//
				//    public function down(): void
				//    {
				//        Schema::table('posts', function (Blueprint $table) {
				//            $table->dropForeign('posts_category_id_foreign');
				//        });
				//    }

λ php artisan migrate

// Y comprobar ahora con el Heidi que la tabla posts tiene las FK 
// Una FK user_id -> users(id)
// Una FK category_id -> categories(id) 

// Vamos a comprobar que tenemos todo de la DDBB y si nos falta algo, pues crearlo
// Vamos a revisar qué nos queda...
// Revisar el modelo con el Heidi para corroborar que la DDBB modelo físico es correcto:

// Me sobran dos campos de la tabla categories
php artisan make:migration remove_dates_from_categories_table 

    public function up(): void
    {
        Schema::table('categories', function (Blueprint $table) {
            $table->dropColumn('start_date'); 
            $table->dropColumn('end_date'); 
        });
    }


    public function down(): void
    {
        Schema::table('categories', function (Blueprint $table) {
            $table->timestamp('start_date')->nullable();
            $table->timestamp('end_date')->nullable();
        });
    }

///////////////////////////////////////////////////////////  FIN OTRAS OPERACIONES POSIBLES 


// En teoría ya es correcto, no haría falta modificarlo más. 
// Si en las próximas acciones vemos sobra/falta algo, ya lo crearemos. 
λ php artisan migrate:status

  Migration name ...................................................................................... Batch / Status
  0001_01_01_000000_create_users_table ....................................................................... [1] Ran
  0001_01_01_000001_create_cache_table ....................................................................... [1] Ran
  0001_01_01_000002_create_jobs_table ........................................................................ [1] Ran
  2025_12_04_144215_create_categories_table .................................................................. [2] Ran
  2025_12_04_144904_create_posts_table ....................................................................... [3] Ran
  2025_12_04_145141_create_tags_table ........................................................................ [4] Ran
  2025_12_04_145357_create_post_tag_table .................................................................... [5] Ran
  2025_12_04_145822_create_comments_table .................................................................... [6] Ran
  2025_12_04_150136_create_images_table ...................................................................... [7] Ran
  2025_12_04_152436_create_roles_table ....................................................................... [8] Ran
  2025_12_04_152552_add_role_to_users_table .................................................................. [9] Ran

// Laravel permite hacer un dump de la DDBB (su estado actual)
php artisan schema:dump // Esto hace copia de base de datos, un dump, se puede ver en VS database>schema>mysql-schema.sql 

// php artisan schema:dump --prune // Eliminando todas las migraciones que teníamos creadas hasta el momento (no lo he probado)


///////////////////////////////////////////// MODELOS 

// Cada modelo es la representación de una Entidad (No una tabla, una entidad del modelo lógico) 
// En Laravel, els models actuen com a pont entre la base de dades i el codi de l'aplicació 
// 	facilitant la interacció amb les dades sense necessitat d'escriure directament consultes SQL.

// L'objectiu principal a l'hora de crear un model és proporcionar una representació 
// 	de les entitats de la base de dades dins de l'aplicació. 

// Els models són comuns per a la interacció entre:
// 	les vistes, per a la creació dels CRUDs amb intervenció de l'usuari,
// 	les API, per a la creació de CRUDs amb intervenció d'un servei extern.

// En una N:M NO HAY MODELO (representación lógica), SI HAY MIGRACION (representación física)
// Es MUY importante respetar la NOMENCLATURA de Laravel, esto permitirá que Laravel pueda asociar automáticamente
// 	un Modelo a su Tabla correspondiente, sin que sea necesario especificarlo explícitamente
// Tabla y Modelo definido por una sola palabra, por ejemplo Posts
// 	Modelo: Post -> En singular y en formato Pascalcase
// 	Tabla: posts -> En plural y en formato snake_case 
// Tabla y Modelo definido por más de una palabra, por ejemplo Posts Types 
// 	Modelo: PostType
// 	Tabla: post_types
// Atención, las Tablas de una relación N:M (que aparecen en el modelo físico), por ejemplo entre Posts y Tags
// 	Modelo: PostTag -> En singular, ordenadas alfabéticamente y en formato sanke_case
//	Tabla: tablaM_tablaN -> (Caso excepcional) En singular, ordenadas alfabéticamente y en formato snake_case
// 
// php artisan make:model Nombre_entidad_singular (primera palabra en mayúsculas) 
// php artisan make:model Post
// php artisan make:model Space_types


// Vamos a crear los MODELOS de nuestro DDBB
//	los Model se crean en app>Models

php artisan make:model Category //Entidad categories
php artisan make:model Comment // Entidad comments
php artisan make:model Image // Entidad images
php artisan make:model Post // Entidad post
php artisan make:model Tag // Entidad tags
// [php artisan make:model User] // // El modelo User YA EXISTE, no hace falta crearlo. 

// No hay más modelos.
// No un Model para la tabla post_tag porque es una N:M pura
// 	luego veremos cómo resolvemos este aspecto

// En el Modelo hay que incluir
// 	Les relacions a altres models (segons el model E/R proporcionat)
// 	Funcions rellevants
// 	Relació d'atributs visibles, no visibles o bloquejats,
// 	Mutadors i accessors,
// 	Casting
// En un Modelo no hace falta especificar los atributos
// SI que hay que definir las relaciones

// Especificación de Relaciones en un Modelo
// 	public function category() // Nombre del Modelo referenciado y deberá ser en singular o plural dependiendo de Padre/Hija
// 		return $this->hasOne(Classe::class); // Relación 1:1 para CADA Modelo de la relación
//		return $this->hasMany(ClasseFilla::class); // Relación 1:N para el Modelo PADRE
// 		return $this->belongsTo(ClassePare::class); // Relación 1:N para el Modelo HIJO
// 		return $this->belongsToMany(Classe::class); // Relación N:M para CADA Modelo de la relación
// 		return $this->belongsToMany(Classe::class)->withPivot('atrib1', 'atrib2', ...); // N:M con atributos para CADA Modelo de la relación

// Vamos con cada uno de ellos definiendo sus relaciones
// Recordar que si referencia a otro modelo, habrá que hacer un import 
// 	use App\Models\Modelo_Referenciado;
// Recordar que 
// 	protected $table = 'blblblb'; // si no fuera nombre estándar de la tabla


//// Modelo Category

php artisan make:model Category // Model de la Entidad categories

class Category extends Model
{
    // protected $table = 'blblblb'; // si no fuera nombre estándar

    public function posts() { // Nombre en plural porque es la padre del 1:N

        return $this->hasMany(Post::class); // 1:N
    }
}

//// Modelo Role

php artisan make:model Role // Model de la Entidad roles

class Role extends Model
{

    public function users() { // Nombre en plural porque es la padre del 1:N

        return $this->hasMany(User::class); // 1:N
    }
}


//// Modelo Comment

php artisan make:model Comment // Entidad comments

class Comment extends Model
{
    use HasFactory;

    public function images()  // Relación Padre 1:N con Image
    {
        return $this->hasMany(Image::class);
    }

    public function post() // Relación Hijo N:1 con Post
    {
        return $this->belongsTo(Post::class);
    }

    public function user() // Relación Hijo N:1 con User
    {
        return $this->belongsTo(User::class);
    }
}

////  Modelo Image

php artisan make:model Image


    public function comment() // 1 Imagen es de 1 Comment
    {
        return $this->belongsTo(Comment::class); // Relación 1:N para el Modelo HIJO
    }


//// Modelo Post

php artisan make:model Post


// En Post 


    public function category() // 1 Post es de 1 Category
    {
      return $this->belongsTo(Category::class);  // N:1
    }

    public function tags() // 1 Post tiene n Tags en relación N:M
    {
        return $this->belongsToMany(Tag::class);  // M:N
    }

    public function user() // 1 Post es de 1 Usuario
    {
        return $this->belongsTo(User::class);   // N:1
    }

    public function comments() // 1 Post tiene n comments
    {
        return $this->hasMany(Comment::class);  // 1:N
    }


// Modelo Tag

php artisan make:model Tag

    public function posts() // 1 Tag tiene n posts
    {
        return $this->belongsToMany(Post::class); // M:N
    }

// Modelo User

    public function comments() // 1 usuario tiene n comments
    {
        return $this->hasMany(Comment::class);  // 1:N
    }

    public function posts() // 1 usuario tiene n posts
    {
        return $this->hasMany(Post::class);  // 1:N
    }

// Observación: Realmente le podríamos poner el nombre de la función que quisiéramos
// no obstante, tener esta nomenclatura es la mejor opción para que Laravel lo identifique

// Ojo, cuando tenemos N:M SIN atributos hay que añadir belongstoMany en ambas 
// Ojo, cuando tenemos N:M CON atributos hay que añadir withPivot (a no ser que la hayamos creado como tabla como es el caso de Comments) 


///////////////////////////////////////////// SEEDERS Y FACTORIES 

// Tenemos la DDBB vacía, ahora necesitamos alimentar la DDBB con datos. 
// Eso se puede hacer con un Seeders y Factories, que permiten inicializar las tablas con datos (incluso datos fake())
// Los Seeders los podemos encontrar en VS database>seeders
// Es una buena técnica para rellenar la DDBB si la recreamos (porque la recreación nos borra el contenido)  

// Para crear un Seeder primero necesitamos el Modelo, recordar que Laravel utiliza MVC. 
// Los Modelos se ubican en app>Models y suelen ser el nombre de la tabla en singular 
// El Seeder usa el Modelo (por tanto, en el Seeder deberá haber un Use del Modelo al que referencia) 

// Creamos un Seeder secundario que será llamado del principal
// 	el seeder principal NO hay que crearlo, ya está creado y se ubica en database>seeders>DatabaseSeeder.php

php artisan make:seeder CategorySeeder // Creamos un seeder para Categories que será llamado del principal (todo Seeder es llamado del principal)
					// El principal DatabaseSeeder.php puede llegar a ser muy grande, por esto podemos llamar desde el principal a otros
					// $this->call(CategorySeeder::class);  // Llamada al Seeder secundarios, como el reción creado
					// Se recomienda dejar el DatabaseSeeder.php limpio con llamadas a los seeders secundarios de cada tabla

// En el database>seeders>DatabaseSeeder.php que es el principal poner esto :
// Ojo, con los use (añade el Hash) y los que sean necesarios


namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Hash; // Importamos Hash para encriptar passwords    

use App\Models\User; // Importamos el modelo User
use App\Models\Role; // Importamos el modelo Role
use App\Models\Category; // Importamos el modelo Category


class DatabaseSeeder extends Seeder
{
    use WithoutModelEvents;

    /**
     * Seed the application's database.
     */
    public function run(): void
    {

        // Insertamos unos roles para poder insertar usuarios con roles asignados
        $Role = new Role(); // Creamos un objeto de tipo Role
        $Role->name = "admin"; // Asignamos role administrador
        $Role->save(); // Creamos la tupla

        $Role = new Role(); // Creamos un objeto de tipo Role
        $Role->name = "user"; // Asignamos role usuario
        $Role->save(); // Creamos la tupla

        $Role = new Role(); // Creamos un objeto de tipo Role
        $Role->name = "guest"; // Asignamos role invitado
        $Role->save(); // Creamos la tupla

        // Inserta un usuario de prueba
        $AdminUser = new User(); // Creamos un objeto de tipo User
        $AdminUser->role_id = 1; //Asignamos role_id = 1 (admin)
        $AdminUser->name = "Tomeweb"; // Asignamos name
        $AdminUser->email ="bmsabater@gmail.com"; // Asignamos email
        $AdminUser->password=Hash::make('12345678'); // Asignamos password
        $AdminUser->save(); // Creamos la tupla 

        // Llamada al seeder de Category
        $this->call(CategorySeeder::class); // Llamamos al seeder de Category

    }
}

// Y en database>seeders>CategorySeeder.php, poner esto:
// Recordar hacer el import de App\Models\Category;

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Models\Category;


class CategorySeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        // Inserta categorías de ejemplo
        $category = new Category();       
        $category->title = "Noves Tecnologies";
        $category->url_clean = "Articles sobre les noves tecnologies.";
        $category->save();

    }
}

// Arrancamos la alimentación de la DDBB con los Seeders
php artisan db:seed // Ejecuta el DatabaseSeeder.php que llamará a los secundarios si los hay
		// No hay rollback de los seeder, pero se puede inicializar la DDBB desde el último dump

php artisan db:seed --class=NomClasse // Ejecuta uno de los Seeders (o Factories). 

// En caso de que falle algún seeder, quedará la DDBB "sucia", con datos de seeders que sí han funcionado
// En caso de que hayamos cometido algún error y deseamos volver a lanzar los seeders

php artisan migrate:fresh --seed // Lleva a cabo un refresco general de la DDBB, desde el último dump borrón y cuenta nueva 
				// Aplicarlo para rehacer los seeders y lanzarlos de nuevo
				// Recordar el dump: λ php artisan schema:dump


// Comprobar con el Heidi que la DDBB es correcta y tiene las tuplas esperadas.

// El Seeder también puede llamar a un JSON, esto significa que podemos alimentar la DDBB desde un cjto de JSONs
// Yo he creado una carpeta denominada JSON en database>JSON donde he depositado el JSON
// Ejemplo; 

// En database>JSON>categories.json, que está confeccionado a mano

{
  "categories": {
    "category": [
      {
        "Nom": "Disseny personal",
		"url": "disseny_personal"
      },
      {
        "Nom": "Il·lustracions",
		"url": "il_lustracions"
      },
      {
        "Nom": "Art i cultura",
		"url": "art_i_cultura"
      }
    ]
  }
}

// Creamos el Seeder para importar el JSON
php artisan make:seeder CategorySeederJSON 

    public function run(): void
    {
        
        // Ejemplo de inserción desde un archivo externo JSON
        $jsonData = file_get_contents('C:\\laragon\\www\\blog-app\\database\\JSON\\categories.json');
        $categories = json_decode($jsonData, true);

        // Insertar cada registro en la tabla mediante un bucle
        foreach ($categories['categories']['category'] as $category) {
            Category::create([
                'title'     => $category['Nom'], // Asignamos title
                'url_clean' => $category['url'], // Asignamos url_clean
            ]);
        }
    }

// Añadimos la llamada en el DatabaseSeeder
        $this->call(CategorySeederJSON::class); // // Llamada al seeder de Category ejemplo inserción desde JSON

// Lo lanzamos y llamará a todos los Seeders creado hasta el momento
php artisan migrate:fresh --seed

// Revisar el resultado con el Heidi


// Laravel proporciona un sistema para rellenar la tablas con datos masivos de prueba generados automáticamente y fake()
// Las Factory permite rellenar la DDBB con datos fake() y aleatorios; es una buena utilidad. 
// Es necesario tener los Modelos ya creado (Seeders y Factories usan los Model)

// Inicialmente creamos dos Factory que se ubicarán en database>factories
// php artisan make:factory <NomTaulaFactory>
php artisan make:factory PostFactory // Y buscarlo en database>factories>PostFactory.php 
// php artisan make:factory UserFactory // Y buscarlo en dabatase>factories>UserFactory.php (Ya está creado)

// Hay que modificar el Modelo indicando que tiene asociado un 'factory'

// En app>Models>User ya viene indicado que hay un Factory con lo siguinte

use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasFactory, Notifiable;

// En app>Models>Post añadir lo siguiente

use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Post extends Model
{
    use HasFactory, Notifiable;


(Revisar desde las 18:00 de día 11-09 la última hora, la explicación fue confusa). 

// En database>factories>UserFactory.php poner esto (revisar y cambiar):

    public function definition(): array
    {
        return [
            'name' => fake()->name(), //Nombre aleatorio
            'email' => fake()->unique()->safeEmail(), // Correo aleatorio sin repeticiones
            'email_verified_at' => now(), // Ahora
            'role' => fake()->randomElement($array = array('admin','user','peon')), //Selección aleatória del role
            'password' => static::$password ??= Hash::make('12345678'), //Así todos tendrán mismo passwd
            'remember_token' => Str::random(10), // Un String con 10 carácteres aleatoriso
        ];
    }

// En database>factories>PostFactory.php poner esto:

use App\Models\User;
use App\Models\Category;

    public function definition(): array
    {
        $title = fake()->sentence(); // Frase aleatoria
        return [
            'title' => $title,
            'url_clean' => Str::slug($title), // Palabra aleatoria
            'content' => fake()->randomHtml(2,3), //contenido html
            'posted' => fake()->boolean ? 'yes' : 'not', // Aleatorio entre yes y not
            'category_id' => Category::inRandomOrder()->first()->id, // Un Category Id aleatorio
            'user_id' => User::inRandomOrder()->first()->id, // Un User Id aleatorio
        ];
    }

// Los factory también se llamarán desde el DatabaseSeeder.php cuando arranquemos los Seeder

        // Llamadas a los factories para generar datos de prueba
        User::factory(5)->create(); // Llamará a este factory 5 veces
        Post::factory(5)->create(); // Llamará a este factory 5 veces

// Arrancamos la alimentación de la DDBB desde el último dump
// Recreará Seeders y llamará a las Factory
php artisan migrate:fresh --seed // Esto lo refresca todo desde el dump borrón y cuenta nueva 
				// Aplicarlo para rehacer los seeders y lanzarlos de nuevo
				// Ojo, pude fallar un montón, porque hay que hacer imports por todo 
				// Se puede volver a lanzar sin problemas con el php artisan migrate:fresh --seed
				// Los de DatabaseSeeder.php son 
					use App\Models\User; // Importamos el modelo User
					use App\Models\Post; // Importamos el modelo Post
					use App\Models\Role; // Importamos el modelo Role
					use App\Models\Category; // Importamos el modelo Category

// Comprobar todo en la DDBB mediante HeidiSQL
// 	Ha creado Categorias del Seeder
// 	Ha creado Categorias del JSON
// 	Ha creado 5 Users (además del Admin) del factory
// 	Ha creado 5 Posts del factory


// Seguimos definiendo Factories para las tablas que nos quedan 
// Hasta ahora, con Seeders o Factories hemos insertado datos en:
User
Category 
Post

// Creamos Factories para el resto de tablas
// Recordar que el el Modelo hay que añadir e Importar 
// 	use HasFactory, Notifiable; 

php artisan make:factory CommentFactory
php artisan make:factory ImageFactory
php artisan make:factory TagFactory

// OJO, si de un error como el que sigue, te has olivado del HasFactory o import en el Model 

  Symfony\Component\ErrorHandler\Error\FatalError
  Trait "App\Models\HasFactory" not found

// Añadimos el código al DatabaseSeeder y quedaría así 
// 	Recordar hacer imports por todo
// 	Recordar que en el Modelo hay que añadir use HasFactory, Notifiable; //Hay un Factory para este Modelo
// Para post_tag se utiliza una técnica especial 


use App\Models\User; // Importamos el modelo User
use App\Models\Post; // Importamos el modelo Post
use App\Models\Role; // Importamos el modelo Role
use App\Models\Category; // Importamos el modelo Category
use App\Models\Comment; // Importamos el modelo Comment
use App\Models\Image; // Importamos el modelo Image
use App\Models\Tag; // Importamos el modelo Tag


class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        // Insertamos una tupla específica de Users
        // Usuario de Inicio (Administrador creado manualmente)
        // Sería más correcto tener un  $this->call(UserSeeder::class); 
        $AdminUser = new User(); // Creamos un objeto de tipo User
        	$AdminUser->name = "Tomeu"; // Asignamos name
        	$AdminUser->email ="bmesabater@gmail.com"; // Asignamos email
        	$AdminUser->role = "superjefetop"; //Asignamos role
        	$AdminUser->password = Hash::make('12345678'); // Asignamos password
        $AdminUser->save(); // Creamos la tupla 
        
        // Llamamos a Seeders externos 
        $this->call(CategorySeeder::class); // Llamada al seeder de Category ejemplo inserción 1 tupla
        $this->call(CategorySeederJSON::class); // Llamada al seeder de Category ejemplo inserción desde JSON

        User::factory(5)->create(); // Llama al UserFactory x 5
        $posts = Post::factory(5)->create(); // Llama al PostFactory x 5 // Se usará para post_tag
        Comment::factory(5)->create(); // Llama al CommentFactory x 5
        Image::factory(5)->create(); // Llama al ImageFactory x 5
        $tags = Tag::factory(5)->create(); //Llama al TagFactory x 5 // Se usará para post_tag

        // Generamos tuplas para la tabla post_tag
        $posts->each(function ($post) use ($tags) {
            $post->tags()->attach(
                $tags->random(rand(1, 5))->pluck('id')->toArray()
            );
        });
    }
}

// CommentFactory

use Illuminate\Database\Eloquent\Factories\Factory;
use App\Models\User;
use App\Models\Post;    

    public function definition(): array
    {
        return [
            'comment'=> fake()->sentence(), // Frase aleatoria
            'user_id' => User::inRandomOrder()->first()->id, // Un User Id aleatorio
            'post_id' => Post::inRandomOrder()->first()->id, // Un Post Id aleatorio
        ];
    }


// Pongo aquí el código ejemplo del ImageFactory (entero) 

<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use App\Models\Comment;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Image>
 */
class ImageFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'url' => $this->faker->imageUrl(), // Es una URL a una imagen fake
            'comment_id' => Comment::inRandomOrder()->first()->id, // Un Id de Comment aleatorio
        ];
    }
}

// TagFactory

    public function definition(): array
    {
        $name = fake()->sentence();
        return [
            'name'=> $name, 
            'url_clean' => Str::slug($name)
        ];
    }

// Vamos a darle ya y comprobarlo con el Heidi 
php artisan migrate:fresh --seed 

// Comprobar la DDBB con el Heidi, comprobar que se han insertado las tuplas. 



/////////// TINKER / ELOQUENT

// L'eina 'Tinker'
// Per provar tenim una consola com 'Tinker' que permet interactuar amb l'aplicació mitjançant el terminal. 
// Permet executar ordres de PHP, manipular models, accedir a la base de dades, provar codi 
// sense haver de crear rutes o scripts addicionals.

// Per iniciar Tinker, cal executar:
php artisan tinker


// Eloquent ORM: cada taula de la BD es mapejada per un model, mentre que cada registre es tracta com una instància d'aquest model.
// Arrancamos el Tinker o herramienta para probar las in

> use app\models\Comment;

> User::all(); // Vuelca todos los registros, devuelve una colección
> Category::all(); // Vuecla todos los registros, devuelve una colección

> User::find(6); // Vuelca el registro con Id=6, devuelve una instanacia
> User::where('id',6)->get(); // Idéntica a la anterior pero devuelve una instancia Builder y se puede encadenar, se debe acabar con get() / first()

> User::orderby('created_at','desc')->get(); // Encadenado
> User::orderby('created_at','desc')->take(3)->get(); // Encadenado

> User::where('id','>',3)->get(); // Los que su id sea > 3
> User::where('id','>',3)->first(); // El primero tal que su id sea > 3

> User::where('id','>',3)->orderby('id','asc')->get();
> User::where('id','>',3)->orderby('role','desc')->get();
> User::where('id','>',3)->orderby('name','desc')->first();

// Combinación de first + where 
> User::firstWhere('id','>',3)->orderby('name','desc');

> User::where('role','admin')->get();

> Post::select('id','title','posted')->where('id','>',3)->orderBy('created_at','asc')->get();
> Post::where('posted','=','yes')->orderBy('created_at','asc')->select('id','title','posted')->get();
