/////////////////////////////////////////////////////

Bartolomé Sabater
Emili Darder - Desenvolupament Entorn Servidor - 2024-25-26

Repaso Models

Repaso Conexión con la DDBB Ejemplos:
	SQL directo
	Query Builder
	Eloquent
	pluck

Finalización del CRUD con funcionalidade básica
Todavía no se aplicará la renderización final 

	index()
	show()
	edit()
	update()
	destroy()

/////////////////////////////////////////////////////


//// Hagamos un poco de repaso del tema anterior  

// Recordamos como obtener las Routes
php artisan route:list

// Son las Route que nuestro proyecto ofrece a los usuarios. 
//      pero no hace más que ofrecer una ruta válida. 


// En routes>web.php cualquier Route, aunque no codifiquemos nada, será un ruta válida, pero en blanco
// En routes>web.php a cualquier Route podemos añadir todo el HTML que necesitemos y customizar la respuesta
// 	pero es mejor dejarlas en blanco y asociarlas con una View o un Controller aplicando el paradigma "MVC"
// Una Route puede llamar a una View (resources>views) para mostrar HTML plano.
// Una Route puede llamar a un método de un Controller (app>Http>Controllers) para lógica (reglas de negocio, gestió de la información, etc.)


//////  En paradigma MVC: Una ROUTE llama a un método de un CONTROLLER que utilizará un MODEL para gestionar una información mostrando el resultado en una VIEW 
//////	Usuario -> Route(parametros) -> Controller(f() / Model) -> View(Model') -> Usuario 
////// 	El paradigma MVC no es exclusivo de Laravel, 
//////		es un patrón de arquitectura de software que se utiliza para independizar los datos (Modelo) de la visualización (Vista) de la lógica de negocio (Controlador)


// Recordar del tema anterior routes>web.php la Route::resource('/postCRUD', PostControllerCRUD::class); 
//      esta Route generaba automáticamente todas las Route hacia un Controller con métodos pensados para para CRUD

// Recordar también del tema anterior que podemos implementar Rules (app>Rules) a nuestra conveniencia
// 	ejemplo: app>Rules>Uppercase.php que se usa desde app>Http>Requests>GuardarPostRequest.php
//  	y GuardarPostRequest se utiliza en la función store() del Controller

// Recordar también que el orden de las validaciones definidas en GuardarPostRequest.php será el que se aplica
// 	ante varios errores en el mismo campo solamente muestra el primero según se hayan definido las validaciones

//// Fin del repaso del tema anterior  


////// Veamos en este tema diferentes maneras de comunicación con la DDBB (Recordatorio o Refresco de conocimientos)

// Laravel permite :
//
//	- SQL sin procesar (en crudo)
//	- Un generador de consultas Query Builder 
//	- y el ORM (Object Relational Mapper) de Eloquent
//
// Se recomendado el ORM de Eloquent si el proyecto no es muy grande y complejo (por ejemplo un CRUD), y si los SQL son los 'normales'
// En caso de necesitar un SQL 'complejo' con muchas 'join' que requiera de optimización, es mejor aplicar Query Builder 
// Se desaconseja el SQL directo sin procesar, no se aprovechan las facilidades ni de Query Builder ni de Eloquent
//	y además, se acceder a la DDBB directamente saltándote los Model donde pudiera haber lógica
//	SQL directo como última opción 


*********************************** Ejemplos de SQL DIRECTO

// Hacemos algún ejemplo de SQL DIRECTO (SQL sin procesar) 
// Probamos algunas sentencias de ejemplo en el app>Http>Controllers>PostControllerCRUD.php en la function create(); 
// Quedaría así:

use Illuminate\Support\Facades\DB; 
public function create()
{
    $user = DB::select('select * from users');
    dd($user);  // para ver la respuesta del select anterior
      
    return view('post.create'); // Llama a la vista create.blade.php
}

// Ejecutarlo, para ver la respuesta: se ve gracias a dd($user);
http://<example-app.test>/postCRUD/create

// Y se confirma que podemos lanzar un SQL directamente contra la DDBB
// Otro ejemplo con clausula 'where'

public function create()
{
        // $user = DB::select('select * from users');
        $user = DB::select('select * from users where id = :id',['id' => 1]);
        dd($user); // para ver la respuesta del select anterior

        return view('post.create'); // Llama a la vista create.blade.php
}

// Se pueden hacer insert / update / delete, etc. Cualquier sentencia que necesitemos
// 	no obstante, se desaconseja, o solo en situaciones muy específicas, porque es 'directo'
// 	no usa los Model, observad como extrae toda la tupla sin filtrar. 


*********************************** Ejemplos de QUERY BUILDER

// Otra manera de ejecutar SQL es mediante el QUERY BUILDER (constructor de queries de Laravel) 
// Veamos ejemplos en el mismo fichero PostControllerCRUD.php con Query Builder
// No devuelve un array como SQL Directo, ahora devuelve una collection que tiene otras propiedades interesantes. 

public function create()
{

        // Ejemplos de SQL DIRECTO
        // $user = DB::select('select * from users');
        // $user = DB::select('select * from users where id = :id', ['id' => 1]); 

        // Ejemplos con el QUERY BUILDER 
        // $user = DB::table('users')->where('email','bmsabater@gmail.com')->get(); // Ejemplo con where x = y
        // $user = DB::table('users')->where('role','!=',1)->get(); // Ejemplo con where x != y

        // dd($user); // Muestra el resultado del select anterior 


    	return view('post.create'); // Llama a la vista create.blade.php
}

// La gran diferencia es que el Query Builder devuelve un collection y el SQL directo devuelve un array
// Un collection es mucho más rico en información y podemos manipularlo


*********************************** Ejemplos con ELOQUENT

// Veamos ELOQUENT, que es el recomendado mientras el SQL no sea muy complejo
// Una gran ventaja es que utiliza los Model que hemos creado en app>Models para mapear las entidades (tablas)
//      esto significa que respetará las restricciones, mapeos, etc. que tuviéramos definidos en los Model
// Los Model de app>Models representan cada una de la tablas físicas de la DDBB y sus relaciones 
// Se aplican las instrucciones Insert, Update, Delete en las tablas a través los Model
// No siempre es mejor Eloquent o Query Builder, depende del caso, y puede haber mezcla sin problemas. 
// Query Builder es mejor para consultas grandes y pesadas (con muchas Join), porque podemos construir la query de manera custom 
// Eloquent mejor para CRUDs, código más amigable, SQL sencillo, ideal para proyectos de tamaño contenido sin queries complejas. 
// Incluso mezcla: los CRUDs con Eloquent y SQL complejo con Query Builder 
// Aunque es totalmente correcto, se desaconseja la forma de SQL directo, no se aprovechan las ventajas de Query Builder o Eloquent


*********************************** Repaso Model 

// Entonces, ahora hay que crerar los Model app>Models
// Por convención creamos la tabla física de la DDBB en plural (Categories) y el modelo en Singular (Category)

php artisan make:model Category // que ya tenemos creado para la tabla categories

// A partir de la creación de un Model, luego podemos crear todo lo que necesitamos con el artisan
// Por ejemplo:
	//php artisan make:model Category --migration 		// Crea Modelo y su migración 
	//php artisan make:model Category --factory o -f	// Crea el factory
	//php artisan make:model Category --seed o -s		// Crea el seed
	//php artisan make:model Category --controller o -c	// Crea controlador
	//php artisan make:model Category --policy
	//php artisan make:model Category -mfsc			// Crea migración, factory, seed y controller. 
	//php artisan make:model Category --all			// Lo crea todo, si ya hay algo creado mejor no usarlo

// En los Model tenemos unas convenciones que nos permiten manipular la DDBB
// Por ejemplo, en un Model podemos renombrar la tabla (darle un alias) 
// Ejemplo (+abajo): donde class Category es la que hace referencia a la tabla categories de la DDBB
// Recordar que en su dia hicimos un php artisan make:model Category // Modelo para tabla "categories". Ojo nombre del Model en singular
// Un Model es como una Class que representa a una tabla física de la DDBB y sus relaciones
// Se engancha en los Model, es donde creas la Class que representa una entidad (no una relación, no hará falta crear un Model en relaciones) 
// Model mapea Entidad (no relación, no hará falta) 


class Category extends Model
{
    use HasFactory;
    protected $table = 'categorias'; // Asignación del Model a una tabla, mapeo con un nuevo nombre físico de la tabla
}

// IMPORTANTE: Category será el nombre de la class en todo la aplicación
// 	'categories' es el nombre de la tabla física de la DDBB, 
// 	esto permite cambiar nomenclatura de la DDBB física sin tener que cambiar toda la aplicación 
// Si no pones nada, se entiende que en la DDBB está el nombre en singular 'categories' 

// Podemos hacer otros cambios en el Model en relación a la tabla física de la DDBB
	// protected $table = 'categories'; Podem assignar un nom diferent de la taula 
	// protected $primaryKey = 'category_id'; Podem assignar una primary key 
	// public $incrementing = false; Si volem que el primary key no sigui autoimcremental
	// protected $keyType = 'string'; Si volem que el primary key no sigui un enter
	// public $timestamps = false; Si la taula no te les columnes de temps(created_at, updated_at)

// Otros 'conceptos' que podemos manejar con los Model y que nos facilitan la programación
// Ejemplos:
	// protected $dateFormat = 'Y-m-d'; Formato de fecha
	// const CREATED_AT = 'creation_date'; const UPDATED_AT = 'updated_date'; Podem assignar noms diferents a les columnes de timestamp   
	// protected $connection = 'sqlite'; Si un model concret es connecte a una altre base de dades
	// protected $attributes = ['posted' => 'not']; Si volem assignar valors per defecte

*********************************** Fin Repaso Model


*********************************** Ejemplos con ELOQUENT

// Veamos ahora cómo usamos ELOQUENT (recordar que usan los Model)
// Para las pruebas usaremos index() de app>Http>Controllers>PostControllerCRUD.php 

public function index()
{
    $post = Post::all(); // Donde Post es la class de la tabla posts all() es obtener todos los registros

    dd($post); // volcado del resultado 
}

// Arrancarlo recordando las routes con php artisan route:list
//GET|HEAD        postCRUD .................................. postCRUD.index › PostControllerCRUD@index
http://<example-app.test>/postCRUD

// Fijarse que el resultado es una Eloquent\Collection y nos devuelve muchísima información
// Probamos otras instrucciones del Eloquent en index()

public function index()
{
    //$posts = Post::all(); // Donde Post es la classe de la tabla posts all() es obtener todos los registros
    $posts = Post::find(1); // Busca registro con la PK = 1 

    dd($posts); // volcado del resultado 
}
http://<example-app.test>/postCRUD // Ahora NO devuelve un collection 

// Podemos probar también
        $posts = Post::find([1, 3]); // Busca registro con la PK = 1, PK = 3

// Añadimos un WHERE de SQL con Eloquent

public function index()
{
        // $posts = Post::all(); // Donde Post es la classe de la tabla posts all() es obtener todos los registros
        // $posts = Post::find(1); // Busca registro con la PK = 1 
        // $posts = Post::find([1, 3]); // Busca registro con la PK = 1, PK = 3

        // Aplicamos un WHERE
        $posts = Post::where('posted','=','not')->get(); // Where posted=not

        dd($posts); // volcado del resultado 
}
http://<example-app.test>/postCRUD // Esto devuelve una Eloquent\Collection

// Por defecto el where toma el '=', no hacía fala ponerlo, es redundante
// Ejemplo de concatenación de where

public function index()
{
        // $posts = Post::all(); // Donde Post es la classe de la tabla posts all() es obtener todos los registros
        // $posts = Post::find(1); // Busca registro con la PK = 1 
        // $posts = Post::find([1, 3]); // Busca registro con la PK = 1, PK = 3

        // Aplicamos un WHERE
        //$posts = Post::where('posted','=','not')->get(); // Where posted=not
        $posts = Post::where('posted','not')->where('id','>',2)->get(); // Where posted=not AND id>2; 

        dd($posts); // volcado del resultado 
}
http://<example-app.test>/postCRUD // Esto devuelve una collection 

// Truco (un poco de andar por casa) para saber la Query real que lanza Eloquent
// 	forzar algún error y la pantalla de errores mostrará la query generada
// Probarlo como sigue y veremos que la query es "select * from `posts` where `posted2` = not and `id` > 2"

$posts = Post::where('posted2','not')->where('id','>',2)->get(); // Hay un error en :where('posted2','not'), debería ser 'posted'
http://example-app.test/postCRUD // Genera un error SQLSTATE[42S22]: Column not found: 1054 Unknown column 'posted2' in 'where clause' (Connection: mysql, SQL: select * from `posts` where `posted2` = not and `id` > 2)

// Para hacer un 'OR' en un 'WHERE' se codifica de la siguiente manera:
$posts = Post::where('posted','not')->orWhere('id','>',2)->get(); // Where posted=not OR id>2

// Ojo con la concatenación, aplicar paréntesis. Ojo con el orden del Where
// Ojo con proyectos grandes con SQL sobre DDBB grandes, hay que tener un poco de conocimiento sobre Eloquent o Query Builder para SQL óptimo

// Ejemplo de query complejo con Eloquent:
        $posts = Post::where('posted','yes')
                    ->orwhere(function($query) {
                        $query->where('posted','not')
                        ->where('category_id','2');
                    })->get();
//  EL query generado sería : select * from posts where posted = 'yes' or (posted = 'not' and category_id = 2);
http://<blog-app.test>/postCRUD

// Siempre hemos hecho un ->get(), pero podríamos hacer un ->first() que sería obtener solamente el primer registro
$posts = Post::where('posted','not')->where('id','>',2)->first(); // Where posted=not OR id>2 y solo el primero 

// Un Order By 
$posts = Post::where('posted','not')->orderBy('id','desc')->get(); // Ordenado

	// Con Eloquent tenemos todas las posibilidades de SQL

	// whereBetween / orWhereBetween y whereNotBetween / orWhereNotBetween
	// Aquests mètodes verifiquen que el valor d'una columna estigui entre dos valors i el seu contrari.

	// whereIn / whereNotIn / orWhereIn / orWhereNotIn
	// Aquests mètodes verifiquen que el valor d'una columna donada estigui dins de la matriu de valors donada

	//whereNull / whereNotNull / oWhereNull / oWhereNotNull
	// Aquests mètodes verifiquen que el valor de la columna donada sigui NULL.

	//whereDate / whereMonth / whereDay / whereYear / whereTime
	// Aquests mètodes s'utilitzen per comparar el valor d'una columna de tipus data.

	// whereColumn / orWhereColumn
	//  El mètode whereColumn pot usar-se per a verificar que dues columnes siguin igual

// Revisar en la documentación de Laravel la documentación de Eloquent (https://laravel.com/docs/12.x/eloquent)

// Refinamos, ahora deseamos extraer solamente un conjunto de columnas de la tabla, no todas
// 	para ellos tenemos dos sistemas:

// El select clásico
$posts = Post::select('title','url_clean','content')->get(); // Extracción de columnas específicas 

// El 'pluck', que devuelve un array con los valores seleccionados. 
// 	devuelve una estructura más sencilla. 
// Ejemplo, una columna de una tabla solamente haríamos pluck

$posts = Post::pluck('title'); // Simplifica la salida, solamente los valores 
$posts = Post::pluck('title','id'); // Simplifica la salida, valores con clave asociada
$posts = Post::pluck('url_clean','id'); // Simplifica la salida, valores con clave asociada

// Limite y offset de una consulta de DDBB
// $posts =  Posts::take(10)->skip(10)->get(); // De la 10 a la 20, es para paginar la salidad de la SELECT (no lo he probado) 


// Todos los ejemplos que se han probado juntos

    public function index()
    {
        // Ejemplo de consulta con Eloquent ORM
        //$posts = Post::all(); // SELECT * FROM posts;
        //$posts = Post::find(1); // SELECT * FROM posts WHERE id=1 LIMIT 1;
        //$posts = Post::find([1,3]); // SELECT * FROM posts WHERE id IN (1,3);
        //$posts = Post::where('posted','yes')->get(); // SELECT * FROM posts WHERE posted='yes';
        //$posts = Post::where('posted','not')->orderBy('id','desc')->get(); // SELECT * FROM posts WHERE posted='not' ORDER BY id DESC;
        //$posts = Post::where('posted','yes')->orderBy('id','desc')->take(2)->get(); // SELECT * FROM posts WHERE posted='not' ORDER BY id DESC LIMIT 2;
        //$posts = Post::where('posted','not')->where('id','>',2)->get(); // 'Where posted = not AND id > 2'; 
        //$posts = Post::where('posted2','not')->where('id','>',2)->get(); // Forzamos un error de columna no existente para volcar la query generada por Eloquent
        //$posts = Post::where('posted','not')->orWhere('id','>',2)->get(); // 'Where posted = not OR  id > 2 '; 
        //$posts = Post::with(['user','category'])->where('posted','yes')->orderBy('id','desc')->get(); // SELECT * FROM posts WHERE posted='not' ORDER BY id DESC LIMIT 2;
        /*
        $posts = Post::where('posted','yes')
                    ->orwhere(function($query) {
                        $query->where('posted','not')
                            ->where('category_id','2');
                    })->get(); // 'Where posted = yes OR (posted = not AND category_id=2)';

        */
        //$posts = Post::where('posted','not')->where('id','>',2)->first(); // Where posted=not OR id>2 y solo el primero 
        //$posts = Post::where('posted','not')->orderBy('id','desc')->get(); // Ordenado
        //$posts = Post::select('title','url_clean','content')->get(); // Extracción de columnas específicas

        //$posts = Post::pluck('title'); // Simplifica la salida, solamente los valores 
        //$posts = Post::pluck('title','id'); // Simplifica la salida, valores con clave asociada
        //$posts = Post::pluck('url_clean','id'); // Simplifica la salida, valores con clave asociada
        
        //dd($posts);  // para ver la respuesta del select anterior
    }

************************** Fin Ejemplos ELOQUENT


************************** Retomamos nuestro CRUD 

******************* Retomamos el index()


// Visto todo lo anterior, vamos ahora a crear el listado de Posts, 
// 	    usaremos la función index() de PostControllerCrud 
// La extracción de la info de la DDBB la queremos maquetar y no volcar con un dd(), por tanto, usaremos una View
// Mucho cuidado con la sintaxis cuando lo pasamos del Controller a la View, 
//      el resultado de Eloquent va en $posts, y lo pasaremos a la vista como 'posts'

public function index()
{
	$posts = Post::all(); // Obtención de todas las publicaciones en $posts
	return view('post.index',['posts' => $posts]);  // Llamada a la View pasando $posts para maquetar el resultado del SQL
}

// Ahora hay que crear la View 'index' en resources>view>post>index.blade.php (hacemos copy & paste de la create.blade.php) 
// En general, en resources>view>post> tendremos que crear las View que usaremos desde el PostControllerCRUD
// 	copy & paste de la create.blade.php y renombrar a index.blade.php
// 	borrar todo el código que hay dentro que venía del create y substituirlo por el siguiente código
// Recordar que esta vista recibe datos del PostControllerCRUD mediante return view('post.index',['posts' => $posts]); 
// 	por tanto, ahora tendremos que manejar el 'posts'
// Ojo con el content porque contiene código html, si genera problemas, mejor no mostrarlo. 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Posts</title>
</head>
<body>

    <table border='1'>
        @foreach ($posts as $post)
            <tr>
                <td>{{ $post->id }}</td>
                <td>{{ $post->title }}</td>
                <td>{{ $post->url_clean }}</td>
                <td>{{ $post->posted }}</td>
                <td>{{ $post->content }}</td> <!-- podría dar problemas -->
                <td>{{ $post->user_id }}</td>
                <td>{{ $post->category_id }}</td>
                <td>{{ $post->created_at }}</td>
                <td>{{ $post->updated_at }}</td>
            </tr>
        @endforeach
    </table>

</body>
</html>


// idem para Categories

public function index()
{
    $categories = Category::all(); // Obtención de todas las categorías en $categories
    return view('category.index', ['categories' => $categories]); // Llama a la vista category/index.blade.php pasando $categories para maquetar el resultado del SQL
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Categories</title>
</head>
<body>

    <table border='1'>
        @foreach ($categories as $category)
            <tr>
                <td>{{ $category->id }}</td>
                <td>{{ $category->title }}</td>
                <td>{{ $category->url_clean }}</td>
                <td>{{ $category->created_at }}</td>
                <td>{{ $category->updated_at }}</td>
            </tr>
        @endforeach
    </table>

</body>
</html>


// Probarlo utilizando las Routes correctas

λ php artisan route:list
GET|HEAD        postCRUD ........................... postCRUD.index › PostControllerCRUD@index
GET|HEAD        categoryCRUD ............... categoryCRUD.index › CategoryControllerCRUD@index

http://<example-app.test>/postCRUD
http://<blog-app.test>/categoryCRUD


*********************************** show()

// Creamos ahora la View para la visualización de un único registro
// 	en PostControllerCRUD modificamos la función de show()

    public function show(string $id)
    {
        $posts = Post::find($id); // Extrae registro con PK = id
        return view('post.show',['post'=>$posts]); // // Llama a la vista post/show.blade.php pasando el post seleccionado 
    }

// Hay que crear la View 'show' en resources>view>post>show.blade.php (hacemos copy & paste de la create.blade.php) 
// Dentro de la View 'show' poner este código, es de solo salida, es un show, solo muestra información, no hay formulario 
// Recordar que la llamamos con un ['post' => $posts], lo que significa que la info estár dentro de 'post', que solo será un registro

    <table border='1'>
            <tr>
                <td>{{ $post->id }}</td>
                <td>{{ $post->title }}</td>
                <td>{{ $post->url_clean }}</td>
                <td>{{ $post->posted }}</td>
                <td>{{ $post->content }}</td> <!-- el HTMl podría generar problemas -->
                <td>{{ $post->user_id }}</td>
                <td>{{ $post->category_id }}</td>
                <td>{{ $post->created_at }}</td>
                <td>{{ $post->updated_at }}</td>
            </tr>
    </table>


// Idem para Category

    public function show(string $id)
    {
        $category = Category::find($id); // Extrae registro con PK = id
        return view('category.show',['category'=>$category]); // Llama a la vista category/show.blade.php pasando la categoría seleccionada 
    }

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show Category</title>
</head>
<body>

    <table border='1'>
            <tr>
                <td>{{ $category->id }}</td>
                <td>{{ $category->title }}</td>
                <td>{{ $category->url_clean }}</td>
                <td>{{ $category->created_at }}</td>
                <td>{{ $category->updated_at }}</td>
            </tr>
    </table>

</body>
</html>

// Llamarlo, ojo con la llamada, consultarla de la lista de llamadas
λ php artisan route:list

GET|HEAD        postCRUD/{postCRUD} ....................................... postCRUD.show › PostControllerCRUD@show
GET|HEAD        categoryCRUD/{categoryCRUD} ........................categoryCRUD.show › CategoryControllerCRUD@show

http://<example-app.test>/postCRUD/1
http://<blog-app.test>/categoryCRUD/1

// Si lo llamamos con algún registro que no existe genera un error de incontrolado, probarlo
http://<example-app.test>/postCRUD/50 // Genera un error. 

// Tenemos algo en la función del Controller que nos puede ayudar en estos casos

public function show(string $id)
{
    //$posts = Post::find($id); // Extrae regisro con PK = id
    $posts = Post::findorfail($id); // Genera una respuesta http de error en caso de not found. Un 404
    return view('post.show',['post' => $posts]);  // Recordar crear la vista 
}

http://<example-app.test>/postCRUD/50 // Genera un error controlado 404 Not Found

// Hay una manera más directa de hacerlo todo;
// Cambiar todo el código de la funcion por lo siguiente, que incluye el 404 
// Mucho cuidad con el 'nombre del parámetro' mirar bien las routes

GET|HEAD        postCRUD/{postCRUD} ....................................... postCRUD.show › PostControllerCRUD@show
GET|HEAD        categoryCRUD/{categoryCRUD} ........................categoryCRUD.show › CategoryControllerCRUD@show

public function show(Post $postCRUD)
{
    return view('post.show',['post' => $postCRUD]);  // El nombre del parámetro es así, postCRUD/{postCRUD}  
}

// idem para Category

public function show(Category $categoryCRUD)
{
    return view('category.show',['category' => $categoryCRUD]);  // El nombre del parámetro es así, categoryCRUD/{categoryCRUD}  
}

// Probarlo con y sin error
http://<example-app.test>/postCRUD/5 // Muestra el registro
http://<blog-app.test>/categoryCRUD/5
http://<example-app.test>/postCRUD/50 // Genera un error controlado 404 Not Found
http://<blog-app.test>/categoryCRUD/50


*********************************** edit()

// Vamos ahora a la edición de los recursos; de los Posts y Categories. 
// Crearemos la View como resources>views>post>edit.blade.php
// Aplicaremos la misma técnica que en show(), para el 404 not found automático 

GET|HEAD        postCRUD/{postCRUD}/edit ............................. postCRUD.edit › PostControllerCRUD@edit

public function edit(Post $postCRUD)
{
    return view('post.edit',['post' => $postCRUD]); // Recordar crear la vista edit
}

// Cambiar el edit.blade.php en Post por el siguiente código:
// 	Es muy importante el 'name' de los input para que el Request los mapee bien, sobre todo en el ejemplo siguiente en el update()
// 	Si te olvidas del 'name' del 'form' la info no se envía, y el Request no la encuentra 
// 	es una restricción de http, debe tener 'name' los campo del formulario

// Copiar formulario del create, pero ahora el 'form' formulario debe apuntar al update(), no al store() como el create (mirarlo bien en rutas)
// La petición al update() deberá ser método PUT (mirarlo en las rutas) 
// Revisar bien la llamada 
//	<form action="{{ route('postCRUD.update', ['postCRUD' => $post->id ]) }}" method="post">
//	sim miramos la Route veremos que tenemos que llamar a postCRUD/{postCRUD}
//	entonces la route será 'postCRUD.update' con un parámetro 'postCRUD' que toma el valor de '$post->id'
//	revisarlo en el código fuente del html que se genera
// También recordar incluir los valores por defecto, por ejemplo value={{$post->url_clean}} en los 'input' del formulario 

λ php artisan route:list
PUT|PATCH       postCRUD/{postCRUD} ........................................... postCRUD.update › PostControllerCRUD@update

// El resource>views>post>edit.blade.php queda finalmente como sigue:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Post</title>
</head>
<body>

    <h3>Edit Post</h3>

    <!-- Gestión de errores -->
    @if ($errors->any())
      <div class="alert alert-danger">
          <ul>
              @foreach ($errors->all() as $error)
                  <li>{{ $error }}</li>
              @endforeach
          </ul>
      </div>
    @endif

    <form action="{{ route('postCRUD.update', ['postCRUD' => $post->id ]) }}" method="post">
        @csrf <!-- Security Token -->	
        @method('PUT') <!-- Cambio de method a 'PUT', en caso contrario llamaría al show -->
        
        <label for="title">Títol</label>
        <input type="text" style="@error('title') border-color:RED; @enderror" value="{{$post->title}}" name="title" />
        @error('title')
            <div>{{$message}}</div>
        @enderror
      
        <label for="url_clean">Url neta</label>
        <input type="text" value="{{$post->url_clean}}" name="url_clean" />
        @error('url_clean')
            <div>{{$message}}</div>
        @enderror
                
        <label for="content">Contingut</label>
        <textarea style="@error('content') border-color:RED; @enderror" name="content" col="3" >{{$post->content}}</textarea>
        @error('content')
            <div>{{$message}}</div>
        @enderror

        <input type="submit" value="Update" >
    </form>

</body>
</html>

// Consultamos las rutas para llamarlo 
GET|HEAD        postCRUD/{postCRUD}/edit ............................................... postCRUD.edit › PostControllerCRUD@edit

// Probarlo mediante la siguiente ruta (No tenemos generado todavía el update(), solo mostrará en pantalla el registro
// http://<example-app.test>/postCRUD/{postCRUD}/edit // cambiando el {postCRUD} por diferentes valores

http://<example-app.test>/postCRUD/2/edit
http://<example-app.test>/postCRUD/50/edit // Genera un 404


// Idem para Category 

GET|HEAD        categoryCRUD/{categoryCRUD}/edit ..................... categoryCRUD.edit › CategoryControllerCRUD@edit
PUT|PATCH       categoryCRUD/{categoryCRUD} ........................... categoryCRUD.update › CategoryControllerCRUD@update


public function edit(Category $categoryCRUD)
{
    return view('category.edit',['category' => $categoryCRUD]); // Hace uso de Route Model Binding
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Category</title>
</head>
<body>

    <h3>Edit Category</h3>
    <!-- Gestión de errores -->
    @if ($errors->any())
      <div class="alert alert-danger">
          <ul>
              @foreach ($errors->all() as $error)
                  <li>{{ $error }}</li>
              @endforeach
          </ul>
      </div>
    @endif

    <form action="{{ route('categoryCRUD.update', ['categoryCRUD' => $category->id ]) }}" method="post">
        @csrf <!-- Security Token -->	
        @method('PUT') <!-- Cambio de method a 'PUT', en caso contrario llamaría al show -->
        
        <label for="title">Títol</label>
        <input type="text" style="@error('title') border-color:RED; @enderror" value="{{$category->title}}" name="title" />
        @error('title')
            <div>{{$message}}</div>
        @enderror
      
        <label for="url_clean">Url neta</label>
        <input type="text" value="{{$category->url_clean}}" name="url_clean" />
        @error('url_clean')
            <div>{{$message}}</div>
        @enderror

        <input type="submit" value="Update" >
    </form>

</body>
</html>

GET|HEAD        categoryCRUD/{categoryCRUD}/edit ........................... categoryCRUD.edit › CategoryControllerCRUD@edit
http://<blog-app.test>/categoryCRUD/3/edit
http://<blog-app.test>/categoryCRUD/30/edit


*********************************** update()

// El edit hecho en el ejemplo anterior deberá llamar al update()
// Ahora cambiamos el update() del PostControllerCRUD, llamado desde el edit() 
// 	app>Http>Controllers>PostControllerCRUD.php
// vamos a la función update(), tiene que quedar así: 

    // Recordar que viene del function edit(), el form de la view llama aquí 
    // PUT|PATCH    postCRUD/{postCRUD} .......... postCRUD.update › PostControllerCRUD@update

public function update(Request $request, Post $postCRUD)
{

    $postCRUD->title = $request->title; // Actualiza title por el que viene del request
    $postCRUD->url_clean = $request->url_clean; // Actualiza url_clean por el que viene del request
    $postCRUD->content = $request->content; // Actualiza content por el que viene del request

    $postCRUD-> update(); //Actualizamos el registro de la DDBB 
    return back(); // Vuelve a la página origen, y vuelve a cargar el registro actualizado
}

// Y nos va quedando un PostControllerCRUD muy limpio y ordenado
// 	no hay muchas líneas de código 
// Probarlo, aunque falta refinar el update()

http://<blog-app.test>/postCRUD/5/edit
http://<blog-app.test>/postCRUD/6/edit


// Aplicamos un pequeño refinamiento en update()
// Como está ahora, el udpate() no aplica las restricciones que sí aplicamos en el create()
// Probarlo con un update poniendo el título en minúsculas o título en blanco y lo aceptará, 
//      comprobarlo sacando la lista de posts o editarlas

http://<example-app.test>/postCRUD/4/edit // aquí poner title en blanco o en minúculas
http://<example-app.test>/postCRUD/4 // editar y compruebar contenido 
 
// Deberíamos aplicar controles, al estilo que los aplicamos en el create() 
// Recordar que tenemos el app\Http\Requests\GuardarPostRequest.php que nos filtraba los input
// 	no podemos reutilizarlo tal cual (hay un control para titulo y url únicos) y en update 
//     	nos daría problemas. Optamos por generar un control para update()

php artisan make:request ActualizarPostRequest // Crea un request en app>Http>Requests 

// Copiar el contenido del GuardarPostRequest.php y modificarlo de la siguiente manera

   public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'title' => ['required','min:5','max:255', new Uppercase],
            'url_clean' => 'required|min:5|max:255',
            'content' => 'required|min:5|max:255',
        ];
    }

    public function messages() {
        return [
            'title.required' => 'El título debe estar informado',
            'title.min' => 'Título mínimo son 5 carateres',
            'title.max' => 'Título máximo son 255 caracters',
            'url_clean.required' => 'La url debe estar informada',
            'url_clean.min' => 'La url mínimo son 5 carateres',
            'url_clean.max' => 'La url máximo son 255 caracters',
            'content.required' => 'El content debe estar informada',
            'content.min' => 'El content mínimo son 5 carateres',
            'content.max' => 'El content máximo son 255 caracters',
        ]; 
    }

// Modificar la llamada para que actue el request recién creado 
public function update(ActualizarPostRequest $request, Post $postCRUD)

// Y probar ahora de actualizar rompiendo las rules del update 


// Para simplificar todavía más el código 
// 	podemos substituir todo el código anterior de la siguiente manera

public function update(ActualizarPostRequest $request, Post $postCRUD)
{
        $postCRUD-> update($request->all()); //Actualizamos el registro de la DDBB 
        return back(); // Vuelve a la página origen, y vuelve a cargar el registro actualizado
}

// Probarlo y puede dar un error (Add [_token] to fillable property to allow mass assignment on [App\Models\Category].)
// Hay que modificar algo, ver primero el app>Models>user.php
// Se especifican los atributos que son asignables de manera massiva 'The attributes that are mass assignable'.
// Lo anterior se considera un insert 'masivo' de información, es decir, no campo a campo
// Y hay que especificar qué campos admiten este insert 'masivo'
// Por tanto habrá que modificar el app>Models>Post.php dejarlo como sigue:

class Post extends Model
{
    use HasFactory;

    protected $fillable = [ 
        'title',
        'url_clean',
        'content',
        'user_id',
        'category_id', 
    ];
}


// Probarlo otra vez, ahora debería funcionar el udpate() 
// Lo visto es una manera para no tener que añadir uno a uno todos los campos en el udpate(), se considera que se hace de manera 'masiva'
// Así el Controller queda más limpio (ensuciando un poco el Model, pero es mejor), si no el Controller acabaría siendo muy grande e inmantenible

// Para indicar todo lo contrario
// 	es decir, que un campo es INMODIFICABLE 

protected $guarded = [
       'id'
]; 


// Al final el app>Models>Post.php quedaría como sigue

class Post extends Model
{
    use HasFactory, Notifiable;

    // Campos que se pueden asignar masivamente (desde formulario)
    protected $fillable = [ 
        'title',
        'url_clean',
        'content',
        'user_id',
        'category_id', 
    ];

    // Campos inmodificables
    protected $guarded = [
        'id'
    ];


////  Idem para Category 

// PUT|PATCH  categoryCRUD/{categoryCRUD} .... categoryCRUD.update › CategoryControllerCRUD@update

// Función update() del CategoryControllerCRUD queda así 

public function update(Request $request, Category $categoryCRUD)
{
     $categoryCRUD-> update($request->all()); //Actualizamos el registro de la DDBB 
     return back(); // Vuelve a la página origen, y vuelve a cargar el registro actualizado
}

// El app>Models>Category.php quedaría como sigue

namespace App\Models;

use App\Models\Post;
use Illuminate\Database\Eloquent\Model;

class Category extends Model
{
    // Campos inmodificables
    protected $guarded = [
        'id'
    ]; 

    // Campos que son updatables de manera masiva
    protected $fillable = [
        'title',
        'url_clean',
    ]; 

    public function posts() { // Nombre en plural porque es la padre del 1:N
        return $this->hasMany(Post::class); // 1:N
    }
}


// Ver como en app>Models>User.php tiene algunos campos 'hidden' que no se muestran en los formularios

// Observación: no podemos aplicar la creación masiva en el store() del PostControllerCRUD.php 
//	porque hemos puesta una casuística en user_id y category_id (selección random) 
//
//      $post->user_id = User::all()->random()->id; // Para que la FK user_id funcione, elegimos al azar
//      $post->category_id = Category::all()->random()->id; // Para que la FK category_id funcione, elegimos al azar
//
// Estas casuísticas nos impiden aplicar $postCRUD-> update($request->all());
//	en general, si necesitamos tratar algún dato no podremos usar la creación / actualización masiva



*********************************** destroy()


// Finalmente, vamos a la última operación del CRUD la eliminación de un recurso
// Vamos a la función destroy() del PostControllerCRUD.php

λ php artisan route:list

DELETE   postCRUD/{postCRUD} ......................postCRUD.destroy › PostControllerCRUD@destroy

    public function destroy(Post $postCRUD)
    {
        // Eliminación del registro 
        $postCRUD->delete(); 
        return back(); 
    }

// Pero no haremos una página HTML de delete, no hace falta
// En el index(), añadiremos un formulario para llamar al delete()
// 	es decir, que para cada elemento aparezca un botón de delete
// El resources>views>post>index.blade.php queda así:
 
<table border='1'>
@foreach ($posts as $post)
<tr>
    <td>{{ $post->id }}</td>
      <td>{{ $post->title }}</td>
      <td>{{ $post->posted }}</td>
      <td>{{ $post->content }}</td>
      <td>{{ $post->created_at }}</td>
      <td>{{ $post->updated_at }}</td>
      <td>
        <form action="{{route('postCRUD.destroy', ['postCRUD' => $post->id ])}}" method="POST">
          @method('DELETE')
          @csrf
          <button type="submit" class="btn tbn-danger btn-sm">Delete</button>
        </form> 
      </td>
    </tr>
@endforeach
</table>

// Observar que originalmente en el index() no tenemos @csrf ya que no se envía nada en index(), es de output
//	ahora es una solicitud de borrado, por tanto, necesitamos el Security Token
// Eliminar algunos y comprobarlo en la DDBB que se ha borrado físicamente. 

// Ejercicio: Aplicar la misma idea para el edit()
// Sería aplicar la misma idea que en index() con botón para Route que llame a show()
// Modificamos la View post.index para añadir un botón
// Recordar la Route que deberemos asociar a cada botón
php artisan route:list 
 GET|HEAD        postCRUD/{postCRUD} .............................. postCRUD.show › PostControllerCRUD@sho

// La View index.blade.php quedaría de la siguiente manera

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Posts</title>
</head>
<body>

    <h3>Index Post</h3>

    <table border='1'>
        @foreach ($posts as $post)
            <tr>
                <td>{{ $post->id }}</td>
                <td>{{ $post->title }}</td>
                <td>{{ $post->posted }}</td>
                <td>{{ $post->content }}</td>
                <td>{{ $post->created_at }}</td>
                <td>{{ $post->updated_at }}</td>
                <td>
                    <form action="{{route('postCRUD.destroy', ['postCRUD' => $post->id ])}}" method="POST">
                      @method('DELETE')
                      @csrf
                      <button type="submit" class="btn tbn-danger btn-sm">Delete</button>
                    </form> 
                </td> 
                <td>
                    <form action="{{route('postCRUD.show', ['postCRUD' => $post->id ])}}" method="GET">
                      @method('GET')
                      @csrf
                      <button type="submit" class="btn tbn-danger btn-sm">Show</button>
                    </form> 
                </td> 
            </tr>
        @endforeach
    </table>

</body>
</html>


//// Idem en Category

DELETE   categoryCRUD/{categoryCRUD} ......categoryCRUD.destroy › CategoryControllerCRUD@destroy

    public function destroy(Category $categoryCRUD)
    {
        // Eliminación del registro 
        $categoryCRUD->delete(); 
        return back(); 
    }

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Categories</title>
</head>
<body>

    <table border='1'>
        @foreach ($categories as $category)
            <tr>
                <td>{{ $category->id }}</td>
                <td>{{ $category->title }}</td>
                <td>{{ $category->url_clean }}</td>
                <td>{{ $category->created_at }}</td>
                <td>{{ $category->updated_at }}</td>
                <td>
                    <form action="{{route('categoryCRUD.destroy', ['categoryCRUD' => $category->id ])}}" method="POST">
                        @method('DELETE')
                        @csrf
                        <button type="submit" class="btn tbn-danger btn-sm">Delete</button>
                    </form> 
                </td>
            </tr>
        @endforeach
    </table>

</body>
</html>


// Ya tenemos una Web que aplica un CRUD que funciona, aunque es muy sencillo y con un diseño muy básico 
// Este tema ha servido para explicar conceptos básicos para confeccionar un CRUD sobre una tabla de DDBB
// Hay que aplicar un diseño más avanzado, y que el Tailwindcss tenga efecto, 
//	se verá en los próximos temas, este tema era pura funcionalidad

// Ejercicio, Repetir todo con otras tablas.  

/////////////////////////////////////////////////////////////////////////////////// FIN DEL TEMA 